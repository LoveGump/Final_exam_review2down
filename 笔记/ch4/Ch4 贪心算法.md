# Ch4 贪心算法

直观上说，一个算法是贪心的，则此算法是通过一些小的步骤来建立一个解，在每一步根据**局部情况选择**一个决定使得某些主要的指标能得到优化。

==**存在一个局部判断规则**可以用来构造问题的**最优解**。==

本章逐渐介绍两个基本的方法来证明一个贪心算法对一个问题能够提供一个最优解。

✓ **贪心算法领先**的概念：每一步都比其他的算法好，从而证明产生了一个最优解。

✓ **交换论证**：考虑对这个问题的任何可能解，逐渐把它转换成由贪心算法找到的解，而且不影响解的质量。从而证明了贪心法找到了一个至少与其它解一样好的解。

## 4.1 区间调度：贪心算法领先

### 规则：

我们应该接受**最早结束**的需求，即f(i)尽可能小的需求i为第一个需求。这样的好处是**资源尽可能早被释放**，以便于安排下面的需求。

### 伪代码

<img src="/Users/gump/大二资料（更新版）/alg/笔记/ch4/assert/image-20250528223343432.png" alt="image-20250528223343432" style="zoom:67%;" />



### 证明

贪心算法领先的思路来**严格说明**：需要证明这个解是最优的，为了便于比较，令O**是一个最优的区间集合**。证明的主要思想是贪心算法生成的集合A “领先”于集合O.

命题：由上面贪心规则返回的集合A中的区间都是相容的。

目标是为了证明|A|=|O|。

好的，我们可以使用“贪心领先”（Greedy Stays Ahead）的思路来证明区间调度问题的贪心算法（最早结束时间优先）的正确性。

## 区间调度问题

**问题描述：** 给定 n 个活动（或区间），每个活动 i 都有一个开始时间 sᵢ 和一个结束时间 fᵢ。目标是选出最大数量的互不重叠（兼容）的活动。

### 贪心算法：最早结束时间优先 (Earliest Finish Time First - EFT)

1. **排序：** 将所有区间（活动）按照它们的**结束时间**进行非递减排序。

2. **选择：** 初始化一个空集合 `S` 作为选中的活动。

3. 迭代：

    遍历排序后的区间：

   - 对于第一个区间，直接将其选入 `S`。
   - 对于后续的每个区间 `j`，如果它的开始时间 `sⱼ` 大于或等于集合 `S` 中最后一个选入活动的结束时间，则将区间 `j` 加入 `S`。

4. **结果：** 集合 `S` 即为选出的最大兼容活动集。

------

### "贪心领先" 证明思路

我们将证明，贪心算法在每一步所做的选择都“不差于”任何最优解中的对应选择。具体来说，贪心算法选择的第 `i` 个活动的结束时间，总是不晚于任何最优解中第 `i` 个活动的结束时间。

#### 引理：贪心选择的活动结束时间领先

设 `G = {g₁, g₂, ..., gₖ}` 是贪心算法选出的 `k` 个活动，按结束时间排序（这自然是算法处理的顺序）。 设 `O = {o₁, o₂, ..., oₘ}` 是任意一个最优解选出的 `m` 个活动，也按结束时间排序。

我们要证明：对于所有 `1 ≤ i ≤ min(k, m)`，都有 `f(gᵢ) ≤ f(oᵢ)`，其中 `f(x)` 表示活动 `x` 的结束时间。

**证明 (通过数学归纳法)：**

- **基础情况 (i=1)：**
  - 贪心算法选择的第一个活动 `g₁` 是所有活动中**结束时间最早**的那个（或者之一，如果有多个结束时间相同的）。
  - `o₁` 是最优解 `O` 中的第一个活动（按结束时间排序）。
  - 根据贪心算法的选择规则，`f(g₁) ≤ f(o₁)`。因为如果 `f(o₁) < f(g₁)`，贪心算法一定会选择 `o₁` (或具有相同最早结束时间的另一个活动) 作为第一个活动，而不是 `g₁`。
  - 因此，基础情况成立。
- **归纳步骤：**
  - 假设对于某个 `j < min(k,m)`，`f(gⱼ) ≤ f(oⱼ)` 成立（归纳假设）。
  - 我们需要证明 `f(gⱼ₊₁) ≤ f(oⱼ₊₁)`。
  - `gⱼ₊₁` 是贪心算法在选择了 `gⱼ` 之后选择的下一个活动。这意味着 `gⱼ₊₁` 是所有与 `gⱼ` 兼容（即开始时间 `s(gⱼ₊₁) ≥ f(gⱼ)`）的活动中，结束时间最早的那个。
  - `oⱼ₊₁` 是最优解 `O` 中在 `oⱼ` 之后的下一个活动。因此，`oⱼ₊₁` 必须与 `oⱼ` 兼容，即 `s(oⱼ₊₁) ≥ f(oⱼ)`。
  - 根据归纳假设，我们有 `f(gⱼ) ≤ f(oⱼ)`。
  - 结合以上两点，我们得到 `s(oⱼ₊₁) ≥ f(oⱼ) ≥ f(gⱼ)`。
  - 这表明活动 `oⱼ₊₁` 与贪心算法选择的活动 `gⱼ` 是兼容的。因此，`oⱼ₊₁` 是贪心算法在选择 `gⱼ` 之后的一个**候选活动**。
  - 贪心算法在选择 `gⱼ₊₁` 时，会从所有与 `gⱼ` 兼容的活动中选择结束时间最早的那个。既然 `oⱼ₊₁` 是这些候选活动之一，那么贪心算法选出的 `gⱼ₊₁` 的结束时间必然不会晚于 `oⱼ₊₁` 的结束时间，即 `f(gⱼ₊₁) ≤ f(oⱼ₊₁)`。
  - 因此，归纳步骤成立。

**引理证毕。** 这个引理表明，贪心算法的每一步选择都使其在“结束时间”上保持领先或持平于任何最优解。

------

#### 最优性证明 (通过反证法)

现在我们用这个引理来证明贪心算法产生的解是最优的。

假设贪心算法得到的解 `G` (包含 `k` 个活动) 不是最优的。这意味着存在一个最优解 `O` (包含 `m` 个活动)，使得 `m > k`。

1. 根据引理，对于所有 `1 ≤ i ≤ k`，我们有 `f(gᵢ) ≤ f(oᵢ)`。
2. 考虑最优解 `O` 中的第 `k+1` 个活动 `oₖ₊₁` (因为假设 `m > k`，所以这个活动存在)。
   - 由于 `oₖ₊₁` 是最优解中继 `oₖ` 之后的活动，它必须与 `oₖ` 兼容，即 `s(oₖ₊₁) ≥ f(oₖ)`。
   - 根据引理，我们知道 `f(gₖ) ≤ f(oₖ)`。
   - 所以，`s(oₖ₊₁) ≥ f(oₖ) ≥ f(gₖ)`。
3. 上述不等式 `s(oₖ₊₁) ≥ f(gₖ)` 表明，活动 `oₖ₊₁` 与贪心算法选出的第 `k` 个活动 `gₖ` 是兼容的。
4. 这意味着，在贪心算法选择了 `gₖ` 之后，活动 `oₖ₊₁` 是一个可供选择的候选活动。
   - 如果贪心算法在选择了 `gₖ` 之后就停止了 (即贪心解的大小为 `k`)，那就意味着在所有与 `gₖ` 兼容的活动中，它找不到可以再选择的活动了。
   - 但是，我们已经证明了 `oₖ₊₁` 是与 `gₖ` 兼容的。
   - 这就产生了一个矛盾：贪心算法本应该能够选择 `oₖ₊₁` (或者其他某个结束时间更早且与 `gₖ` 兼容的活动)，从而得到一个大小至少为 `k+1` 的解。这与贪心算法得到解的大小为 `k` 相矛盾。
5. 因此，最初的假设 `m > k` 是错误的。所以必然有 `m ≤ k`。
6. 又因为 `O` 是一个最优解，而 `G` 是贪心算法产生的一个可行解，所以可行解的大小不可能超过最优解的大小，即 `k ≤ m`。
7. 结合 `m ≤ k` 和 `k ≤ m`，我们得出 `k = m`。

### 时间复杂度

该算法主要包含以下几个步骤：

1. **排序 (Sorting)：**
   - 算法的第一步是将所有 `n` 个区间（活动）按照它们的结束时间进行非递减排序。
   - 使用标准的比较排序算法（如快速排序、归并排序或堆排序），这一步的时间复杂度是 O(nlogn)，其中 `n` 是区间的数量。
2. **选择和迭代 (Selection and Iteration)：**
   - 初始化一个空集合 `S` 用于存放选中的活动。这需要 O(1) 时间。
   - 将排序后的第一个区间加入 `S`。这需要 O(1) 时间。同时，记录下这个区间的结束时间，作为“上一个选中活动的结束时间”（`last_finish_time`）。
   - 然后，算法需要遍历剩余的 `n-1` 个已排序的区间（或者从第二个区间开始到最后一个区间）。在最坏的情况下，它会检查所有 `n` 个区间。
   - 对于每个被检查的区间 `j`，算法会比较其开始时间 `sⱼ` 与 `last_finish_time`。这是一个 O(1) 的操作。
   - 如果 `sⱼ ≥ last_finish_time`，则将区间 `j` 加入 `S`，并更新 `last_finish_time` 为 `fⱼ`。这也是一个 O(1) 的操作。
   - 这个迭代过程总共会执行 `n` 次（或 `n-1` 次）比较和可能的添加操作。因此，整个迭代和选择阶段的时间复杂度是 O(n)。
3. **总时间复杂度：**
   - 算法的总时间复杂度由这些步骤中耗时最长的部分决定。
   - 排序步骤的时间复杂度是 O(nlogn)。
   - 迭代和选择步骤的时间复杂度是 O(n)。
   - 因此，总的时间复杂度是 O(nlogn)+O(n)=O(nlogn)。

## 4.2 最小延迟调度：一个交换论证

## 4.3 最优高速缓存：一个更复杂的交换论证

## 4.4 一个图的最短路径

## 4.5 最小生成树问题

## 4.6 实现Kruskal 算法

## 4.7 聚类

## 4.8 Huffman 码与数据压缩