# Ch2算法分析基础

## 效率

- 定义：
  - （1） 当实现一个算法时，如果它在真实的输入实例上运行的快，那么这个算法是有效的。（与平台无关，实例无关，并且随着输入规模的增长是可以预测的）
  - (2) 在分析的层次上，如果一个算法与蛮力搜索(Brute Force)比较，**最坏情况**下达到质量上更好的性能，就说这个算法是有效的。
  - (3) 如果一个算法有多项式运行时间，称为这个算法是有效的。

## 主要渐进符号 (Asymptotic Notations)

这些符号用来描述函数在输入规模趋向于无穷大时的增长率。

- **O (Big O Notation - 上界)**:
  - **含义**: 表示算法运行时间的**上限**。如果一个算法的时间复杂度是 O(f(n))，意味着当输入规模 n 足够大时，算法的实际运行时间不会超过 c⋅f(n)，其中 c 是一个正常数。
  - **例如**: O($n^2$) 表示算法的运行时间最多与 n2 成正比。
- **Ω (Big Omega Notation - 下界)**:
  - **含义**: 表示算法运行时间的**下限**。如果一个算法的时间复杂度是 Ω(g(n))，意味着当输入规模 n 足够大时，算法的实际运行时间不会低于 c⋅g(n)，其中 c 是一个正常数。
  - **例如**: Ω(nlogn) 表示算法的运行时间至少与 nlogn 成正比。
- **Θ (Big Theta Notation - 紧确界)**:
  - **含义**: 表示算法运行时间的**确切界限**。如果一个算法的时间复杂度是 Θ(h(n))，意味着它既是 O(h(n)) 也是 Ω(h(n))。也就是说，当输入规模 n 足够大时，算法的实际运行时间介于 c1⋅h(n) 和 c2⋅h(n) 之间，其中 c1 和 c2 是正常数。
  - **例如**: Θ(n) 表示算法的运行时间与 n 成线性关系。

------

## 其他相关符号

- **o (Little o Notation - 非紧确上界)**:
  - **含义**: 表示一个函数比另一个函数增长得**显著地慢**。如果 f(n)=o(g(n))，意味着 limn→∞g(n)f(n)=0。它表示 f(n) 的增长速度远小于 g(n)。
  - **与 Big O 的区别**: Big O 允许 f(n) 和 g(n) 增长速度相同（即 f(n) 是 O(g(n)) 可能意味着 f(n) 和 g(n) 的阶数相同），而 Little o 要求 f(n) 的阶数严格小于 g(n)。
- **ω (Little Omega Notation - 非紧确下界)**:
  - **含义**: 表示一个函数比另一个函数增长得**显著地快**。如果 f(n)=ω(g(n))，意味着 limn→∞g(n)f(n)=∞。它表示 f(n) 的增长速度远大于 g(n)。
  - **与 Big Omega 的区别**: Big Omega 允许 f(n) 和 g(n) 增长速度相同，而 Little Omega 要求 f(n) 的阶数严格大于 g(n)。

------

**总结**:

- **O (上限)**: "不会差于..."
- **Ω (下限)**: "不会好于..."
- **Θ (确界)**: "正好是..."
- **o (严格上限)**: "远好于..."
- **ω (严格下限)**: "远差于..."

在实际应用中，**Big O Notation (O)** 是最常用的，因为它提供了算法性能的一个悲观估计（最坏情况），这对于保证系统在各种输入下的可接受性能非常重要。 Θ 符号能更精确地描述算法的平均性能，但分析起来可能更复杂。

## 传递性 ：

**性质**: 如果 $f(n) = O(g(n))$ 并且 $g(n) = O(h(n))$，那么 $f(n) = O(h(n))$​。

**性质**: 如果 $f(n) = \Omega(g(n))$ 并且 $g(n) = \Omega(h(n))$，那么 $f(n) = \Omega(h(n))$。

**性质**: 如果 $f(n) = \Theta(g(n))$ 并且 $g(n) = \Theta(h(n))$，那么 $f(n) = \Theta(h(n))$。

---

### 1. 大O符号 ($O$) 的传递性证明

**性质**: 如果 $f(n) = O(g(n))$ 并且 $g(n) = O(h(n))$，那么 $f(n) = O(h(n))$。

**证明**:

根据 $O$ (Big O) 的定义：

* $f(n) = O(g(n))$ 意味着存在正常数 $c_1 > 0$ 和 $n_1 > 0$，使得对于所有 $n \ge n_1$，都有：
    $0 \le f(n) \le c_1 g(n)$  --- (1)

* $g(n) = O(h(n))$ 意味着存在正常数 $c_2 > 0$ 和 $n_2 > 0$，使得对于所有 $n \ge n_2$，都有：
    $0 \le g(n) \le c_2 h(n)$  --- (2)

我们的目标是证明 $f(n) = O(h(n))$，即需要找到正常数 $c_3 > 0$ 和 $n_3 > 0$，使得对于所有 $n \ge n_3$，都有 $0 \le f(n) \le c_3 h(n)$。

选择 $n_3 = \max(n_1, n_2)$。当 $n \ge n_3$ 时，式 (1) 和式 (2) 同时成立。
将式 (2) 代入式 (1)：
对于所有 $n \ge n_3$：
$f(n) \le c_1 g(n)$
因为 $g(n) \le c_2 h(n)$，所以
$f(n) \le c_1 (c_2 h(n))$
$f(n) \le (c_1 c_2) h(n)$

令 $c_3 = c_1 c_2$。由于 $c_1 > 0$ 且 $c_2 > 0$，因此 $c_3 > 0$。
所以，我们找到了正常数 $c_3$ 和 $n_3$，使得对于所有 $n \ge n_3$，都有 $0 \le f(n) \le c_3 h(n)$。
根据 $O$ 符号的定义，这证明了 $f(n) = O(h(n))$。 

## 可加性：

**性质**: 如果 $f(n) = O(h(n))$ 并且 $g(n) = O(h(n))$，那么 $f(n) + g(n) = O(h(n))$。

**性质**: 如果 $f(n) = \Omega(h(n))$ 并且 $g(n) = \Omega(h(n))$，那么 $f(n) + g(n) = \Omega(h(n))$。

**性质**: 如果 $f(n) = \Theta(h(n))$ 并且 $g(n) = \Theta(h(n))$，那么 $f(n) + g(n) = \Theta(h(n))$。

###  $O$ (Big O) 的可加性证明

**性质**: 如果 $f(n) = O(h(n))$ 并且 $g(n) = O(h(n))$，那么 $f(n) + g(n) = O(h(n))$。

**解释**: 如果两个函数的增长率都被同一个函数 $h(n)$ 所限制（上界），那么它们的和的增长率也被 $h(n)$ 所限制。

**证明**:

根据 $O$ (Big O) 的定义：

* $f(n) = O(h(n))$ 意味着存在正常数 $c_1 > 0$ 和 $n_1 > 0$，使得对于所有 $n \ge n_1$，都有：
    $0 \le f(n) \le c_1 h(n)$  --- (1)

* $g(n) = O(h(n))$ 意味着存在正常数 $c_2 > 0$ 和 $n_2 > 0$，使得对于所有 $n \ge n_2$，都有：
    $0 \le g(n) \le c_2 h(n)$  --- (2)

我们的目标是证明 $f(n) + g(n) = O(h(n))$。这意味着我们需要找到正常数 $c_3 > 0$ 和 $n_3 > 0$，使得对于所有 $n \ge n_3$，都有 $0 \le f(n) + g(n) \le c_3 h(n)$。

选择 $n_3 = \max(n_1, n_2)$。当 $n \ge n_3$ 时，式 (1) 和式 (2) 同时成立。
因此，对于所有 $n \ge n_3$：
$f(n) + g(n) \le c_1 h(n) + c_2 h(n)$
$f(n) + g(n) \le (c_1 + c_2) h(n)$

令 $c_3 = c_1 + c_2$。由于 $c_1 > 0$ 且 $c_2 > 0$，因此 $c_3 > 0$。
同时，因为 $f(n) \ge 0$ 和 $g(n) \ge 0$ (对于足够大的 $n$，或者根据定义，它们是表示资源消耗的函数，通常为非负)，所以 $f(n) + g(n) \ge 0$。

因此，我们找到了正常数 $c_3 = c_1 + c_2$ 和 $n_3 = \max(n_1, n_2)$，使得对于所有 $n \ge n_3$，都有 $0 \le f(n) + g(n) \le c_3 h(n)$。
根据 $O$ 符号的定义，这证明了 $f(n) + g(n) = O(h(n))$。 

## O(nlogn)阶时间的问题

### 快速排序(Quicksort)

### FFT(快速傅立叶变换)

### 归并排序，堆排序

### **最大时间间隔问题**：

给定一组n个时间标签$x1 , …, x_n$ ，一个文件的副本在这些时间到达一个服务器，我们想找出在第一个和最后一个时间标签之间的**最大的**没有文件副本到达的**时间区间**。

## 平方时间

假设平面上给定n个点，每个点由(x,y)坐标指定。需要找最邻近(距离最小)的点对。

## 立方时间

### 问题描述

给定 $N$ 个集合 $S_1, S_2, \ldots, S_N$。这些集合中的每一个都是集合 $\{1, 2, \ldots, n\}$ 的子集。
我们想确定在这些给定的 $N$ 个子集中，是否存在至少一对子集是**不相交**的。所谓不相交，即这两个子集之间没有共同的元素。

**形式化表述：**

* **输入：** 集合列表 $S = [S_1, S_2, \ldots, S_N]$，其中每个 $S_k \subseteq \{1, 2, \ldots, n\}$。
* **问题：** 是否存在索引 $i, j$ (其中 $i \neq j$) 使得 $S_i \cap S_j = \emptyset$？

### 解决思路

对每一对不同的集合 $(S_i, S_j)$（即 $i \neq j$），检查它们之间是否存在共同的元素。

**具体步骤：**

1.  遍历所有可能的集合对 $(S_i, S_j)$，其中 $1 \le i < j \le N$。
2.  对于每一对集合 $S_i$ 和 $S_j$：
    * 判断 $S_i$ 与 $S_j$ 的交集是否为空 ($S_i \cap S_j \stackrel{?}{=} \emptyset$)。
    * 换句话说，确定 $S_i$ 和 $S_j$ 是否**没有**共同的元素。
3.  如果在任何一对 $(S_i, S_j)$ 中发现它们没有共同的元素（即它们的交集为空），则可以断定存在不相交的子集对。问题的答案为“是”。
4.  如果检查完所有可能的对后，每一对都有共同的元素（即交集都不为空），则不存在不相交的子集对。问题的答案为“否”。

```
foreach set Si {
  foreach other set Sj {
    foreach element p of Si {
    	determine whether p also belongs to Sj
    }
    if (no element of Si belongs to Sj)
    report that Si and Sj are disjoint
	}
}
```

## O($n^k$)时间

对某个固定常数k, 我们想知道给定的n个结点的输入图是否有一个大小为k的独立集。

```
foreach subset S of k nodes {
  check whether S in an independent set
    if (S is an independent set)
    	report S is an independent set
  }
}
```

枚举所有k个节点的子集：$\binom{n}{k} = \frac{n(n-1)(n-2)\cdots(n-k+1)}{k(k-1)(k-2)\cdots(2)(1)} \le \frac{n^k}{k!}$

判断k个节点的子集是否独立：$O(k^2)$

所以蛮力搜索的代价为：$O(k^2 \cdot n^k / k!) = O(n^k)$

## 指数时间(Exponential time)

假设给定一个图，需要找一个最大规模的独立集。

```
S* ← ∅
foreach subset S of nodes {
  check whether S is an independent set
  if (S is the largest independent set seen so far) {
    update S* ← S
  }
}
```

$O(n ^2 \times 2^ n )$

## n!时间

`